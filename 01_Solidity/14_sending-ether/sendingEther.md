Solidityでは、Etherの送金は特別な操作であり、注意が必要です。まず、関数がEtherを受け取るためには、その関数に`payable`修飾子を付ける必要があります。また、Etherを送金するためには、`send`、`transfer`、または`call`を使用します。

- `send`と`transfer`は2300ガスを送金先に提供します。これは、送金先が状態を変更するのを防ぎ、リエントラント攻撃を防ぐためです。しかし、これらの関数は、送金先がガスを必要とする複雑な操作を行う場合には使用できません。
- `call`はすべての利用可能なガスを送金先に提供します。これにより、送金先が複雑な操作を行うことが可能になりますが、リエントラント攻撃のリスクがあります。

リエントラント攻撃とは、コントラクトが他のコントラクトにEtherを送金するときに、送金先のコントラクトが元のコントラクトを再度呼び出すことで発生します。これにより、元のコントラクトの状態が予期しない方法で変更される可能性があります。

これを防ぐための一般的なパターンは、"Checks-Effects-Interactions"パターンです。このパターンでは、まずすべての条件を確認し（Checks）、次にコントラクトの状態を変更し（Effects）、最後に他のコントラクトとの相互作用を行います（Interactions）。

## ⭐️課題
1. `deposit`という名前の関数を作成します。この関数は`payable`であり、呼び出し元からEtherを受け取り、内部の状態を更新します。
2. `withdraw`という名前の関数を作成します。この関数は、呼び出し元が以前に預けたEtherを返します。この関数は"Checks-Effects-Interactions"パターンに従う必要があります。
