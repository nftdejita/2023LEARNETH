Solidityでは、*マッピング*はキータイプと対応する値タイプのペアのコレクションです。

マッピングと配列の最大の違いは、キー値のみでしかアクセスできない点です。このためキーがわからない場合、その値にアクセスすることはできません。すべてのデータを知る必要がある場合、またはデータを反復処理する必要がある場合は、キー値を配列で保存して使用する必要があります。

一方既知のキーに基づいて値を取得する場合は、マッピングが有効です。（たとえば、アドレス毎の残高を管理するような場合）。マッピングを使用して値を検索する方が、配列を反復処理するよりも簡単で安価です。配列が大きくなりすぎると、配列を反復処理するためのガスコストが高くなりすぎて、トランザクションが失敗する可能性があります。


### マッピングの作成
マッピングは、構文 `mapping（KeyType => ValueType）VariableName`で宣言されます。
キータイプは、任意の組み込み値タイプまたは任意のコントラクトにすることができますが、参照型にすることはできません。値の型はどの型でもかまいません。

このコントラクトでは、キータイプ`address`を値タイプ`uint`に関連付けるパブリックマッピング`myMap`（6行目）を作成しています。

### 値へのアクセス
マッピングのキーと値のペアを操作するための構文は、配列の構文と似ています。
特定のキーに関連付けられている値を見つけるために、マッピングの名前とキーを角かっこで囲んで示します（11行目）。

注意すべき点として、配列とは対照的に、値がまだ設定されていないキーの値にアクセスしようとしても、エラーは発生しません。マッピングを作成すると、可能なすべてのキーがデフォルト値0にマップされます。

### 設定値
マッピングの名前とキーを角かっこで囲み、新しい値を割り当てることで、キーに新しい値を設定します（16行目）。

### 値の削除
配列のセクションで説明したように、削除演算子を使用して、キーに関連付けられた値を削除できます。これにより、キーがデフォルト値の0に設定されます。


## ⭐️課題
1. ６行目のmyMap定義を変更してキータイプ`address`を値タイプ`uint`に関連付けるパブリックマッピング`balances`を作成します。
2. マッピングバランスで機能するように関数`get`と`remove`を変更します。
3. 関数`set`を変更して、残高マッピングへの新しいエントリを作成します。ただし引数は１つでアドレスが指定されるものとし、マッピングされる値は、指定アドレスのEther残高（グローバル変数）で、書式は`引数で指定されたアドレス.balance`で記述します。

